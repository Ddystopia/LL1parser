#include <string>
#include <utility>
#include <vector>
#include <algorithm>
#include <memory>
#include "../headers/Parser.h"
#include "../headers/Lexer.h"
#include "../headers/Token.h"

#include <iostream>

Parser::Parser()
  : m_tokenId(-1), m_tokens(nullptr)
{}

Parser::~Parser() { clear(); }

std::shared_ptr<Node> Parser::parse(const std::string &source){
  using TokenDefinitions::Grammar;

  Lexer lexer{Lexer()};
  m_tokens = lexer.tokenize(source);

  std::shared_ptr<Node> result(calc(Grammar[0].getType()));
  
  // +1 - index by tokens + EOI, -1 - get last index
  if (m_tokenId + 1 != m_tokens->size() - 1) throw "some"; 

  clear();
  return result;
}

std::shared_ptr<Node> Parser::calc(TokenType token) {
  // memorization
  auto lockation(std::make_pair(m_tokenId, token)); 
  if (auto node(m_cache.find(lockation)); node != m_cache.end()) { 
    setId(node->second.second);
    return node->second.first;
  }

  const Product *prod(Product::getProd(token));
  const std::vector<std::vector<TokenType>> &eqs(prod->getEqualents());
  int startTokenId(m_tokenId);

  for (auto const &eq: eqs) {
    std::vector<std::shared_ptr<Node>> stack{};

    for (auto const &token: eq) {
      if (peek()->getType() != token) { 
        if(token.isProduct()) {
          auto node(calc(token));
        } else break;
      } else {
        stack.push_back(std::make_shared<Node>(get()));
      }
    }

    if (stack.size() == eq.size()) { 
      std::shared_ptr<Node> node{std::make_shared<Node>(token, stack)};
      memorize(lockation, std::make_pair(node, m_tokenId));
      return node;
    }

    setId(startTokenId); 
  }
  return nullptr;
}

const Token* Parser::peek(){
  return m_tokens->at(m_tokenId + 1);
}

const Token* Parser::get(){
  return m_tokens->at(++m_tokenId);
}

void Parser::memorize(
    std::pair<int, TokenType> lockation, 
    std::pair<std::shared_ptr<Node>, int> data) 
{
  m_cache.insert(std::make_pair(lockation, data));
}

void Parser::clear(){
  setId(-1);
  m_cache.clear();

  if (!m_tokens) return;
  for (auto it = m_tokens->begin(); it != m_tokens->end(); it++) 
    delete *it;
  delete m_tokens;
  m_tokens = nullptr;
}

